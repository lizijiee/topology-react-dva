## 二维组态设计

### 1. 需求统计

| 序号 |                           具体需求                           |
| :--: | :----------------------------------------------------------: |
|  1   | 需要有用户权限体系，包括组态图的查看权限和编辑构件库的权限。 |
|  2   |       构件库需要可编辑，包括构件分类和构件的上传命名。       |
|  3   |      需要有在线画组态构件的功能，并可以存储到构件库中。      |
|  4   | 组态构件需要能设定连接点的功能，固定连接点，其他位置不允许进行连接。 |
|  5   |                 组态构件需要能进行动效设计。                 |
|  6   |        组态构件需要能对接实时数据，并支持数据的模拟。        |
|  7   | （待定）需要根据客户的构件列表绘制一套预置的2.5D组态构件图库 |

需求澄清：
0.react版本号？？。
1.用户权限分为两种，一种为普通用户，一种为admin，首页展示相同，普通用户进入项目，左侧编辑构件库不进行显示。仅可以查看首页图文库。
2.构件库中构建分类可编辑，，
构件上传流程：左侧分为构件库和我的构件（不分类只有一个添加按钮），点击我的构建**添加按钮** => 添加右侧变成空白url进入详情页?c=true&class=架构拓扑图 => 文件/保存 进入我的构件。右侧可以进行构件名称及构件类别设置，下拉框可以添加类别。
导入构件也直接显示在画布上，保存时候根据url保存到指定类别中，右侧选择类别及名称进行创建。
图片上传后可以进行预览另一侧选中组件后可以进行添加到节点中。
创建分为**图文设置**和**组件设置**

3.在线画组件库就是构件库的生成过程，<font color="red">具体哪些功能？？自己绘制浏览器无法捕捉呀，而且鼠标移动持续记录浏览器也受不了。</font>
4.固定连接点，其它位置禁止连接，使用过程中的操作问题，跟固定连接点需求没关系，正常设置连接点进行连接就好了。（画布—hideAnchor，autoAnchor）
5.<font color="red">自定义动画效果功能。</font>
6.保存事件中Websocket事件类行。

功能分析：
右侧菜单：【组件设置】，节点中【事件功能】部分

开发进程：
 自定义iconfont示例

#### 1.1 搭建Topology组件平台（静态）

##### 1.1.1 安装UmiJS

> yarn global add umi 

##### 1.1.1 安装UmiJS脚手架

> 创建文件夹topology-react
> yarn create umi 
> 选择app创建一个umi应用
> 不选择typeScript
> 空格选择dva 
> 完成项目创建





> [Umi 小白纪实（一）—— 创建项目&常用配置](https://www.cnblogs.com/wisewrong/p/12160671.html)



> 项目静态页面初步完成。



#### 1.2 权限体系

![flow-account.png](https://cdn.nlark.com/yuque/0/2019/png/179380/1566982730044-9eabaa05-2059-43f9-9981-aef8fe7f06a5.png)

权限控制算是软件项目中的常用功能了。在网站中，权限控制一般分为两个维度：页面级别和页面元素级别。页面元素粒度的权限控制，使用高阶组件进行封装。

```javascript
export  let wrapAuth = ComposedComponent =>class WrapComponent extends Component {
    // 构造
    constructor(props) {
      super(props);
    }
 
    static propTypes = {
      auth:PropTypes.string.isRequired,
    };
 
    render() {
      if (tool.getAuth(this.props.auth)) {
        return <ComposedComponent  { ...this.props} />;
      } else {
        return null;
      }
    }

```

[react高阶组件之经典应用：权限控制](https://blog.csdn.net/qq_40963664/article/details/80744726?utm_source=blogxgwz7)
[react-router4.x 路由权限控制](https://blog.csdn.net/qq_40963664/article/details/80701968)

> topology-vue 使用指南含权限部分
> [手摸手，带你用vue撸后台 系列二(登录权限篇)](https://juejin.cn/post/6844903478880370701)
> [权限项目在线地址](https://panjiachen.github.io/vue-element-admin/#/permission/directive)

#### 1.3 构件库开发

> 构件库需要可编辑，包括构件分类和构件的上传命名。

删除子节点办法，node.children下移除就好。

pen.data是用来保存业务数据的，对应上面的是node.data.data

你自己不要设置id，会自动生成唯一id。如果自己指定id，就按指定的。

#### 1.4 组态构建设置连接点

#### 1.5 权限体系分析

#### 1.6 权限体系分析



### 4.技术点

#### 4.1 [整合多个项目之间iconfont字体互相使用后整合的问题](https://www.cnblogs.com/pipixiaolaohu/p/8005941.html)

> 我的项目 => 更多操作 => 项目编辑 => Font Family

```js
/***
//东方医院app定义的字体引用类名
.iconfont {
    font-family: "iconfont" !important;
    font-size: 16px;
    font-style: normal;
    -webkit-font-smoothing: antialiased;
    -webkit-text-stroke-width: 0.2px;
    }

//超煜集团app定义的字体引用类名
.sy-icon{
    font-family:'iconfont';
    font-size: 24px;
    font-style: normal;
    font-weight: 400;
    line-height: 1;
    -webkit-font-smoothing: antialiased;
    }
***/
```



#### 4.2 react中ref两种结果之——真实DOM、高阶组件实例

> 当 ref 被传递给 `render` 中的元素时，对该节点的引用可以在 ref 的 `current` 属性中被访问。
>
> ```const node = this.myRef.current;```
>
> ref 的值根据节点的类型而有所不同：
>
> - 当 `ref` 属性用于 HTML 元素时，构造函数中使用 `React.createRef()` 创建的 `ref` 接收底层 DOM 元素作为其 `current` 属性。
> - 当 `ref` 属性用于自定义 class 组件时，`ref` 对象接收组件的挂载实例作为其 `current` 属性。
>
> ref返回值：
> 	React 高阶组件通过 ref 获取实例



> [Refs and the DOM](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#accessing-refs)



#### 4.3 react中合成事件冒泡和原生事件冒泡关系

> [React 阻止事件冒泡失效、stopPropagation和stopImmediatePropagation分析，解决stopPropagation没有阻止document冒泡问题](https://blog.csdn.net/dknightl/article/details/99844659)

> 结论：
>
> 1. React组件绑定事件是合成事件，本质上是代理到document上，采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理（可以理解成React所有事件都是绑定在document层）
> 2. 对于React的合成事件对象e，e.stopPropagation()只能阻止React合成事件的冒泡，e.nativeEvent.stopImmediatePropagation只能用来阻止冒泡到直接绑定在document上的事件。
> 3. 要想阻止所有的冒泡事件，只能通过ref获得dom节点监听，用原生事件对象e的e.stopPropagation()去阻止冒泡

>实际应用：
>
>[点击弹窗之外关闭弹窗react demo](https://blog.csdn.net/yangbo10086/article/details/105123406)
>
>[react中button上绑定react事件触发原生body上绑定的事件](https://blog.csdn.net/qq_30114149/article/details/80223494)

#### 4.4 有状态（stateful component）无状态组件（stateless component）、受控非受控

> 受控非受控通过ref判断；
> 有无状态通过是否设置state 进行判断

#### 4.5 react antd 有多个Popover气泡卡片手动控制显隐

链接地址：https://blog.csdn.net/sw_onload/article/details/106870313

> 两种解决方法：
>
> 1. 利用初始渲染列表data（数据），每条数据添加show属性，每次点击将data更新，其它列表数据show为false，再用更新后data数据渲染列表。

```js
// 优化前代码
toggleSetting(value){
    console.log('e',value); // 取反
    this.setState((prevState)=>{return prevState.items.map(e=>{
        if(e.id===value.id){
            e.show=!e.show;// 取反
        }else{
            e.show=false;
        }
        return e
    })})
}
class settingPopover extends React.Component{

    constructor(props) {
      super(props);
      this.inputRef = React.createRef();
    }

    componentDidMount() {
      document.addEventListener('click', this.handleDocumentClick);
    }

    handleDocumentClick=e=>{
      if (!this.inputRef.current||!document.querySelectorAll('.ant-popover-content')[0]) { return; }
      if (!document.querySelectorAll('.ant-popover-content')[0].contains(e.target)) { this.props.toggleSetting({})}
    };

    stopPropa(e){
      e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();
    }

  render() {
    const { moveDown, i, record, menuList, toggleSetting} = this.props;
    
    return (
      <div >
        <Popover 
          placement="rightTop" 
          overlayClassName={styles.popover}
          ref={this.inputRef}
          style={{display:'none'}}
          visible={record.show}
          // destroyTooltipOnHide
          content={
            <ul >
              <li
                onClick={(e)=>{
                  moveDown(i);
                  toggleSetting(record)
                }}
              >
                <i className="iconfont icon-arrow-down" />下移
              </li>
              <li 
                 onClick={()=>{
                   console.log("删除项为：",record);        
                  //  toggleSetting({}); // 数据提交成功返回200,关闭popover
                }}
              >
                <i className="iconfont icon-delete" />删除
              </li>
              <li
              >
               <i className="iconfont icon-edit" />编辑
              </li>
            </ul>
          } 
          trigger="click"
        >
          <i className="topology topology-settings" onClick={(e)=>{
            this.stopPropa(e);
            toggleSetting(record);
            }}></i>
        </Popover>
      </div>)
  }
}
export default connect((state) => ({}))(settingPopover);

```

> 修改完成后：
> 另外注意Popover组件内部触发点击事件不需要在元素内绑定onClick事件，代码如下：

```js
    <Popover 
    placement="rightTop" 
    overlayClassName={styles.popover}
    visible={state.show === record.id && state.visiblePopover} // 修改变成record.id
    onVisibleChange={(e)=>showPopover(e,record.id)}

        <i className="topology topology-settings" onClick={(e)=>{
            this.stopPropa(e);
            toggleSetting(record);
        }}></i>
    </Popover>
```

> <font color="red">**直接调用Popover组件内onVisibleChange回调函数即可，每次点击i标签时，自动触发onVisibleChange回调函数，无论值是否改变。**</font>



```js
class App extends React.Component {
  state = {
    visible: false,
    show: 0,
  };

  hide = () => {
    this.setState({
      visible: false,
      show: 0
    });
  };

  handleVisibleChange = (visible,num) => {
    if(visible){
      this.setState({ visible,show:num });
    }else{
      this.setState({ visible,show:0});
    }
    
  };

  render() {
    return (
      <div>
      <Popover
        content={<a onClick={this.hide}>Close</a>}
        title="Title"
        trigger="click"
        visible={this.state.show === 1 && this.state.visible}
        onVisibleChange={(e)=>this.handleVisibleChange(e,1)}
      >
        <Button type="primary">Click me</Button>
      </Popover>
      <Popover
      content={<a onClick={this.hide}>Close</a>}
      title="Title"
      trigger="click"
      visible={this.state.show === 2 && this.state.visible}
      onVisibleChange={(e)=>this.handleVisibleChange(e,2)}
    >
      <Button type="primary">Click me</Button>
    </Popover>
    </div>
    );
  }
}
```







### 5. 参考资料

>1. 目前已有基础设计器和构件库，地址：https://2d.happybim.com/workspace
>2. 组态网站地址：http://topology.le5le.com/workspace
>3. 优化，但是嵌套项目自身应该存在loading，其它功能是否也存在类似情况，项目自身存在，属于公共用功能[dva-loading 实践用法](https://blog.csdn.net/qq_40963664/article/details/80697708)
>4. [topology官方angular实例](https://github.com/lizijiee/topology/tree/master/examples/angular)
>5. [React 阻止事件冒泡失效、stopPropagation和stopImmediatePropagation分析，解决stopPropagation没有阻止document冒泡问题](https://blog.csdn.net/dknightl/article/details/99844659)
>6. [react高阶组件+ref转发的组合使用](https://www.cnblogs.com/llcdbk/p/13067670.html)
>7. [点击弹窗之外关闭弹窗react demo](https://blog.csdn.net/yangbo10086/article/details/105123406)
>8. [react中button上绑定react事件触发原生body上绑定的事件](https://blog.csdn.net/qq_30114149/article/details/80223494)
>9. [react antd 有多个Popover气泡卡片手动控制显隐](https://blog.csdn.net/sw_onload/article/details/106870313)



>2. 

>

```

```

